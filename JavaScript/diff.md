## [diff算法 🐍](https://juejin.cn/post/6844903607913938951#heading-7)

渲染真实DOM的开销很大，引起整个dom树的重绘和重排

### 比较方式
深度优先、同层比较

### 流程
当数据发生改变时，set方法会让调用`Dep.notify`通知所有订阅者Watcher，订阅者就会调用`patch`给真实的DOM打补丁，更新相应的视图。

`patch`函数接收两个参数`oldVnode`和`Vnode`分别代表新的节点和之前的旧节点
* 判断两节点是否值得比较，值得比较则执行patchVnode
* 不值得比较则用Vnode替换oldVnode

如果两个节点都是一样的，那么就深入检查他们的子节点。如果两个节点不一样那就说明Vnode完全被改变了，就可以直接替换`oldVnode`。

虽然这两个节点不一样但是他们的子节点一样怎么办？别忘了，diff可是逐层比较的，如果第一层不一样那么就不会继续深入比较第二层了。
（我在想这算是一个缺点吗？相同子节点不能重复利用了...）

### patchVnode
当我们确定两个节点值得比较之后我们会对两个节点指定`patchVnode`方法。

这个函数做了以下事情：
+ 找到对应的真实dom，称为`el`
+ 判断`Vnode`和`oldVnode`是否指向同一个对象，如果是，那么直接return
+ 如果他们都有文本节点并且不相等，那么将`el`的文本节点设置为`Vnode`的文本节点。
+ 如果`oldVnode`有子节点而`Vnode`没有，则删除`el`的子节点
+ 如果`oldVnode`没有子节点而`Vnode`有，则将`Vnode`的子节点真实化之后添加到`el`
+ 如果两者都有子节点，则执行`updateChildren`函数比较子节点，这一步很重要

