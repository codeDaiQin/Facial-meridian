# HTTP 

## HTTP 请求方法
  * GET
      HTTP RFC规范中并没有规定GET请求的URI长度，只是说明如果server无法处理太长的URI，可以通过返回414状态码。
  * POST
  * PUT
  * HEAD
  * DELETE
  * PATCH
  * OPTIONS
## HTTP 状态码
  * 1**	 信息，服务器收到请求，需要请求者继续执行操作
  * 2**	 成功，操作被成功接收并处理
  * 3**	 重定向，需要进一步的操作以完成请求
  * 4**	 客户端错误，请求包含语法错误或无法完成请求
  * 5**	 服务器错误，服务器在处理请求的过程中发生了错误
  
  304  206   403禁止  404未找到
  414请求的URI 长度超过了服务器能够解释的长度
## http 1.0 1.1 2.0的不同
### HTTP1.0和HTTP1.1的一些区别
1. __缓存处理__，在HTTP1.0中主要使用header里的If-Modified-Since,Expires来做为缓存判断的标准，HTTP1.1则引入了更多的缓存控制策略例如Entity tag，If-Unmodified-Since, If-Match, If-None-Match等更多可供选择的缓存头来控制缓存策略。
2. __带宽优化及网络连接的使用__，HTTP1.0中，存在一些浪费带宽的现象，例如客户端只是需要某个对象的一部分，而服务器却将整个对象送过来了，并且不支持断点续传功能，HTTP1.1则在请求头引入了range头域，它允许只请求资源的某个部分，即返回码是206（Partial Content），这样就方便了开发者自由的选择以便于充分利用带宽和连接。
3. __错误通知的管理__，在HTTP1.1中新增了24个错误状态响应码，如409（Conflict）表示请求的资源与资源的当前状态发生冲突；410（Gone）表示服务器上的某个资源被永久性的删除。
4. __Host头处理__，在HTTP1.0中认为每台服务器都绑定一个唯一的IP地址，因此，请求消息中的URL并没有传递主机名（hostname）。但随着虚拟主机技术的发展，在一台物理服务器上可以存在多个虚拟主机（Multi-homed Web Servers），并且它们共享一个IP地址。HTTP1.1的请求消息和响应消息都应支持Host头域，且请求消息中如果没有Host头域会报告一个错误（400 Bad Request）。
5. __长连接__，HTTP 1.1支持长连接（PersistentConnection）和请求的流水线（Pipelining）处理，在一个TCP连接上可以传送多个HTTP请求和响应，减少了建立和关闭连接的消耗和延迟，在HTTP1.1中默认开启Connection： keep-alive，一定程度上弥补了HTTP1.0每次请求都要创建连接的缺点。
### HTTP2.0和HTTP1.X相比的新特性
1. __新的二进制格式__（Binary Format），HTTP1.x的解析是基于文本。基于文本协议的格式解析存在天然缺陷，文本的表现形式有多样性，要做到健壮性考虑的场景必然很多，二进制则不同，只认0和1的组合。基于这种考虑HTTP2.0的协议解析决定采用二进制格式，实现方便且健壮。
2. __多路复用__（MultiPlexing），即连接共享，即每一个request都是是用作连接共享机制的。一个request对应一个id，这样一个连接上可以有多个request，每个连接的request可以随机的混杂在一起，接收方可以根据request的 id将request再归属到各自不同的服务端请求里面。
3. __header压缩__，如上文中所言，对前面提到过HTTP1.x的header带有大量信息，而且每次都要重复发送，HTTP2.0使用encoder来减少需要传输的header大小，通讯双方各自cache一份header fields表，既避免了重复header的传输，又减小了需要传输的大小。
4. __服务端推送__（server push），同SPDY一样，HTTP2.0也具有server push功能。
## http 和 https的区别

  * 使用 HTTPS 协议需要到 CA（Certificate Authority，数字证书认证机构） 申请证书，一般免费证书较少，因而需要一定费用。证书颁发机构如：Symantec、Comodo、GoDaddy 和 GlobalSign 等。

  * http是超文本传输协议，信息是明文传输，https则是具有安全性的ssl加密传输协议。

  * http和https使用的是完全不同的连接方式，用的端口也不一样，HTTP 默认工作在 TCP 协议 80 端口，HTTPS 是443。

  * http的连接很简单，是无状态的；HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，比http协议安全。
  
  * HTTP 页面响应速度比 HTTPS 快，主要是因为 HTTP 使用 TCP 三次握手建立连接，客户端和服务器需要交换 3 个包，而 HTTPS除了 TCP 的三个包，还要加上 ssl 握手需要的 9 个包，所以一共是 12 个包。
## TCP3次握手和4次挥手
### 3次握手
  * 第一次：客户端发送请求到服务器，服务器知道客户端发送，自己接收正常。SYN=1,seq=x
  * 第二次：服务器发给客户端，客户端知道自己发送、接收正常，服务器接收、发送正常。ACK=1,ack=x+1,SYN=1,seq=y
  * 第三次：客户端发给服务器：服务器知道客户端发送，接收正常，自己接收，发送也正常.seq=x+1,ACK=1,ack=y+1

### 4次挥手
  * 第一次：客户端请求断开FIN,seq=u
  * 第二次：服务器确认客户端的断开请求ACK,ack=u+1,seq=v
  * 第三次：服务器请求断开FIN,seq=w,ACK,ack=u+1
  * 第四次：客户端确认服务器的断开ACK,ack=w+1,seq=u+1
  
  DISpatch
  
### 为什么3次握手和4次挥手？
  * 三次握手时，服务器同时把ACK和SYN放在一起发送到了客户端那里
  * 四次挥手时，当收到对方的 FIN 报文时，仅仅表示对方不再发送数据了但是还能接收数据，己方是否现在关闭发送数据通道，需要上层应用来决定，因此，己方 ACK 和 FIN 一般都会分开发送。

### 从输入URL到浏览器渲染页面经过哪些步骤
  总体来说分为以下几个过程:
  DNS 解析:将域名解析成 IP 地址
  TCP 连接：TCP 三次握手
  发送 HTTP 请求
  服务器处理请求并返回 HTTP 报文
  浏览器解析渲染页面     分为一下五个步骤：

    根据 HTML 解析出 DOM 树
    根据 CSS 解析生成 CSS 规则树
    结合 DOM 树和 CSS 规则树，生成渲染树
    根据渲染树计算每一个节点的信息
    根据计算好的信息绘制页面

  断开连接：TCP 四次挥手
## http 请求包含哪几个部分（请求行、请求头、请求体）
http协议报文
  1. 请求报文(请求行/请求头/请求数据/空行)
  * 请求行
    * 求方法字段、URL字段和HTTP协议版本
    例如：GET /index.html HTTP/1.1
    get方法将数据拼接在url后面，传递参数受限
    * 请求方法：
    GET、POST、HEAD、PUT、DELETE、OPTIONS、TRACE、CONNECT
  * 请求头(key value形式)
    * User-Agent：产生请求的浏览器类型。
    * Accept：客户端可识别的内容类型列表。
    * Host：主机地址
  * 请求数据
    * post方法中，会把数据以key value形式发送请求
  * 空行
    * 发送回车符和换行符，通知服务器以下不再有请求头
2. 响应报文(状态行、消息报头、响应正文)
    * 状态行
    * 消息报头
    * 响应正文

## 强缓存和协商缓存
* ### 强制缓存
强制缓存就是直接从浏览器缓存查找该结果，并根据结果的缓存规则来决定是否使用该缓存的过程。

不存在该缓存结果和标识，强制缓存失效，则直接向服务器发起请求（跟第一次发起请求一致）
存在缓存结果和标识，但结果已失效，强制缓存失效，则使用协商缓存
存在缓存结果和标识，并且结果未失效，强制缓存生效，直接返回该结果
控制强制缓存的字段分别是Expires和Cache-Control，其中Cache-Control优先级比Expires高。

Expires
Expires是HTTP/1.0控制网页缓存的字段，其值为服务器返回该请求结果缓存的到期时间，即再次发起该请求时，如果客户端的时间小于Expires的值时，直接使用缓存结果。

Expires是HTTP/1.0的字段，但现在浏览器默认使用HTTP/1.1，那么HTTP/1.1中网页缓存是否还是由Expires控制？
到了HTTP/1.1，Expires已经被Cache-Control替代，原因在于Expires控制缓存的原理是使用客户端的时间和服务端返回的时间做对比，那么如果客户端与服务端的时间因为某些原因（例如时区）发送误差，那么强制缓存则会直接失效。

Cache-Control
在HTTP/1.1中，Cache-Control是最重要的规则，主要用于控制网页缓存，主要取值为：

public：所有内容都将被缓存（客户端/代理服务器/CDN等）
private：只有客户端可以缓存，Cache-Control默认值
no-cache：客户端缓存内容，但是是否使用缓存则需要经过协商缓存来验证决定
no-store：所有内容都不会被缓存，即不使用强制缓存，也不使用协商缓存
max-age=xxx：缓存将在xxx秒后失效
 Cache-Control/Expires同时存在时，只有Cache-Control生效
”
* ### 协商缓存
协商缓存就是强制缓存失效后，浏览器携带缓存标识向服务器发起请求，有服务器根据缓存标识决定是否使用缓存的过程，主要有以下两种情况：

协商缓存生效，返回304，服务器告诉浏览器资源未更新，则再去浏览器缓存中访问资 源
协商缓存失效，返回200和请求结果
同样，协商缓存的标识也是在响应报文的HTTP头和请求结果一起返回给浏览器的，控制协商缓存的字段分别有：

Last-Modified/If-Modified-Since
Etag/If-None-Match
其中Etag/If-None-Match优先级比Last-Modified/If-Modified-Since高

Last-Modified/If-Modified-Since
Last-Modified是服务器响应请求时，返回该资源文件在服务器最后被修改的时间。

If-Modified-Since则是客户端再次发起该请求时，携带上次请求返回的Last-Modified值，通过此字段告诉服务器该资源上次请求返回的最后被修改时间。服务器收到该请求，发现请求头含有If-Modified-Since字段，则会根据If-Modified-Since的字段值与该资源在服务器的最后被修改时间做对比，若服务器的资源最后修改时间大于If-Modified-Since的字段值，则重新返回资源，状态码为200；否则返回304，代表资源无更新，可以继续使用缓存文件。

Etag/If-None-Match
Etag是服务器响应请求时，返回当前资源文件的一个唯一标识（由服务器生成）。

If-None-Match是客户端再次发起请求时，携带上次请求返回的唯一标识Etag值，服务端收到该请求后，发现该请求含有If-None-Match，则会根据If-None-Match的字段值与该资源在服务器的Etag值做对比，一致则返回304，代表资源无更新，继续使用缓存文件，否则重新返回资源，状态码为200.

总结

强制缓存优先于协商缓存，若强制缓存生效则直接使用缓存，若不生效则进行协商缓存，协商缓存由服务器决定是否使用缓存，若协商缓存失效，那么代表该请求的缓存失效，重新获取请求结果，再存入浏览器缓存中；生效则返回304，继续使用缓存。


## 浏览器缓存

> Modified 修改

### 强制缓存



### 协商缓存

> 协商缓存就是强制缓存失效后，浏览器携带缓存标识向服务器发起请求，由服务器根据缓存标识决定是否使用缓存的过程

如果协商缓存生效 返回304 状态码

* 控制协商缓存的字段分别有: 
* Last-Modified 在服务器最后被修改的时间 在响应头中
* If-Modified-Since 携带 Last-Modified  在请求头中
* Etag 返回当前文件的一个唯一标识 在响应头中
* If-None-Match 携带 Etag 在请求头中

其中 Etag 优先级要比 Last-Modfied 高
    If-None-Match 优先级要比 If-Modified-Since 高
