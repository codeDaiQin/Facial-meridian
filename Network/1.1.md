# HTTP 1.1 

## 新增特性
### 缓存处理

  HTTP1.0 通过If-Modified-Since,Expires作为缓存判断的标准

  HTTP1.1则引入了更多的缓存控制策略例如Entity tag，If-Unmodified-Since, If-Match, If-None-Match等更多可供选择的缓存头来控制缓存策略。

### 长连接

  TCP在建立连接的初期有慢启动（slow start）的特性，所以连接的重用总是比新建连接性能要好。

  浏览器最大连接数： 6
  `Connection： keep-alive`
  ```
  http {   
    #客户端链接超时时间。为0的时候禁用长连接。即长连接的timeout
    keepalive_timeout 120s;    
    
    #在一个长连接上可以服务的最大请求数目。当达到最大请求数目且所有已有请求结束后，连接被关闭。默认值为100。即每个连接的最大请求数 QPS 
    keepalive_requests 10000;      
  }
  ```

### 错误通知的管理

  新增24个错误状态相应码
  410 -> 服务器上的资源被永久删除

### 带宽优化以及网络连接的使用

  允许只请求资源的某个部分 返回状态码206

### Host🐟头处理

HTTP1.1的请求消息和响应消息都应支持Host头域，且请求消息中如果没有Host头域会报告一个错误（400 Bad Request）。

## 存在の问题

### 1. 长连接过多 占用服务端资源

### 2. 队头阻塞

  HTTP/1.1 时代建立一个 TCP 连接，三个请求组成一个队列发出去，服务器接收到这个队列之后会依次响应，一旦前面的请求阻塞，后面的请求就会无法响应。
  > 
  客户端发送的每一个请求，需要等待服务器回应后才能发送下一个请求，即所有请求在一个队列里，如果队头请求意外阻塞，这样就会造成队头阻塞。即如果队头的请求响应时间太长，会影响后面的请求的处理。

  解决：
  * 并发TCP连接，对于同一个域名，浏览器允许同时开6-8个TCP连接，因为每个TCP连接独立，所以某个TCP中的HTTP请求阻塞，不影响其它TCP连接，所以虽然队头阻塞仍然存在，但因为存在多个独立的TCP连接，所以队头阻塞问题得到一定程度的缓解。
   
  * 域名分片浏览器或者客户端是根据domain（域名）来建立连接的。比如针对www.example.com只允许同时建立2个连接，但mobile.example.com被认为是另一个域名，可以再建立两个新的连接。依次类推，如果我再多建立几个sub domain（子域名），那么同时可以建立的http请求就会更多，这就是Domain Sharding了。连接数变多之后，受限制的请求就不需要等待前面的请求完成才能发出了。这个技巧被大量的使用，一个颇具规模的网页请求数可以超过100，使用domain sharding之后同时建立的连接数可以多到50个甚至更多。